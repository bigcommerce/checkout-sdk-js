{"version":3,"file":"integrations/squarev2.js","mappings":"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","sources":["webpack://@bigcommerce/checkout-sdk/webpack/bootstrap","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/not-initialized-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/squarev2-integration/src/enums.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/standard-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/set-prototype-of.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-execute-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/util-types/guard.ts","webpack://@bigcommerce/checkout-sdk/./packages/squarev2-integration/src/squarev2-payment-processor.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/invalid-argument-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/request-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-invalid-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-argument-invalid-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/order-finalization-not-required-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/squarev2-integration/src/squarev2-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/payment/is-hosted-intrument-like.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/payment/is-vaulted-instrument.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-client-unavailable-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/squarev2-integration/src/squarev2-script-loader.ts","webpack://@bigcommerce/checkout-sdk/./packages/squarev2-integration/src/is-squarev2-window.ts","webpack://@bigcommerce/checkout-sdk/./packages/squarev2-integration/src/create-squarev2-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/to-resolvable-module.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","import StandardError from './standard-error';\n\nexport enum NotInitializedErrorType {\n    CheckoutButtonNotInitialized,\n    CustomerNotInitialized,\n    PaymentNotInitialized,\n    ShippingNotInitialized,\n    SpamProtectionNotInitialized,\n}\n\n/**\n * Throw this error if a method requires a certain initialization call to be\n * made first. Some objects can be constructed but they cannot be used until a\n * separate initialization call is made.\n */\nexport default class NotInitializedError extends StandardError {\n    constructor(public subtype: NotInitializedErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'NotInitializedError';\n        this.type = 'not_initialized';\n    }\n}\n\nfunction getErrorMessage(type: NotInitializedErrorType): string {\n    switch (type) {\n        case NotInitializedErrorType.CustomerNotInitialized:\n            return 'Unable to proceed because the customer step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.PaymentNotInitialized:\n            return 'Unable to proceed because the payment step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.ShippingNotInitialized:\n            return 'Unable to proceed because the shipping step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.SpamProtectionNotInitialized:\n            return 'Unable to proceed because the checkout spam protection has not been initialized.';\n\n        default:\n            return 'Unable to proceed because the required component has not been initialized.';\n    }\n}\n","export enum SquareIntent {\n    CHARGE = 'CHARGE',\n    STORE = 'STORE',\n}\n","import CustomError from './custom-error';\nimport setPrototypeOf from './set-prototype-of';\n\n/**\n * This error type should not be constructed directly. It is a base class for\n * all custom errors thrown in this library.\n */\nexport default abstract class StandardError extends Error implements CustomError {\n    name = 'StandardError';\n    type = 'standard';\n\n    constructor(message?: string) {\n        super(message || 'An unexpected error has occurred.');\n\n        setPrototypeOf(this, new.target.prototype);\n\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, new.target);\n        } else {\n            this.stack = new Error(this.message).stack;\n        }\n    }\n}\n","export default function setPrototypeOf(object: any, prototype: object) {\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(object, prototype);\n    } else {\n        object.__proto__ = prototype;\n    }\n\n    return object;\n}\n","import StandardError from './standard-error';\n\nconst defaultMessage =\n    'Payment cannot be processed for this order, please select another payment method';\n\nexport default class PaymentExecuteError extends StandardError {\n    type = 'custom_provider_execute_error';\n    subtype: string;\n\n    constructor(subtype: string, name: string, message?: string) {\n        super(message || defaultMessage);\n\n        this.name = name;\n        this.subtype = subtype;\n    }\n}\n","export default function guard<T>(value: T, errorFactory?: () => Error): NonNullable<T> {\n    if (value === undefined || value === null) {\n        throw errorFactory ? errorFactory() : new Error('An unexpected error has occurred.');\n    }\n\n    return value as NonNullable<T>;\n}\n","import { fromEvent, merge, Subscription } from 'rxjs';\nimport { distinctUntilChanged, map } from 'rxjs/operators';\n\nimport {\n    BillingAddress,\n    guard,\n    NotInitializedError,\n    NotInitializedErrorType,\n    PaymentExecuteError,\n    PaymentIntegrationService,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport { SquareIntent } from './enums';\nimport SquareV2PaymentInitializeOptions from './squarev2-payment-initialize-options';\nimport SquareV2ScriptLoader from './squarev2-script-loader';\nimport {\n    BillingContact,\n    Card,\n    CardInputEvent,\n    CardInputEventTypes,\n    ChargeVerifyBuyerDetails,\n    Payments,\n    SqEvent,\n    StoreVerifyBuyerDetails,\n} from './types';\n\nexport interface SquareV2PaymentProcessorOptions {\n    applicationId: string;\n    locationId?: string;\n    testMode?: boolean;\n}\n\nexport default class SquareV2PaymentProcessor {\n    private _payments?: Payments;\n    private _card?: Card;\n    private _formValidationSubscription?: Subscription;\n\n    constructor(\n        private _scriptLoader: SquareV2ScriptLoader,\n        private _paymentIntegrationService: PaymentIntegrationService,\n    ) {}\n\n    async initialize({\n        testMode,\n        applicationId,\n        locationId,\n    }: SquareV2PaymentProcessorOptions): Promise<void> {\n        const square = await this._scriptLoader.load(testMode);\n\n        this._payments = square.payments(applicationId, locationId);\n    }\n\n    async deinitialize(): Promise<void> {\n        if (this._formValidationSubscription) {\n            this._formValidationSubscription.unsubscribe();\n        }\n\n        if (this._card) {\n            await this._card.destroy();\n        }\n\n        this._formValidationSubscription = undefined;\n        this._card = undefined;\n        this._payments = undefined;\n    }\n\n    async initializeCard({\n        containerId,\n        style,\n        onValidationChange,\n    }: SquareV2PaymentInitializeOptions): Promise<void> {\n        const { postalCode } = this._paymentIntegrationService.getState().getBillingAddress() || {};\n\n        this._card = await this._getPayments().card();\n        await this._card.attach(`#${containerId}`);\n\n        try {\n            await this._card.configure({ postalCode, style });\n        } catch (_error) {\n            /* Do nothing: we should not block shoppers from buying. */\n        }\n\n        if (onValidationChange) {\n            this._formValidationSubscription = this._subscribeToFormValidation(\n                this._card,\n                onValidationChange,\n            );\n        }\n    }\n\n    async tokenize(): Promise<string> {\n        const result = await this._getCard().tokenize();\n\n        if (result.status !== 'OK' || !result.token) {\n            let errorMessage = `Tokenization failed with status: ${result.status}`;\n\n            if (result.errors) {\n                errorMessage += ` and errors: ${JSON.stringify(result.errors)}`;\n            }\n\n            throw new PaymentExecuteError(\n                'payment.errors.card_error',\n                'SquareV2TokenizationError',\n                errorMessage,\n            );\n        }\n\n        return result.token;\n    }\n\n    async verifyBuyer(token: string, intent: SquareIntent): Promise<string> {\n        return intent === SquareIntent.CHARGE\n            ? this._chargeVerifyBuyer(token)\n            : this._storeVerifyBuyer(token);\n    }\n\n    private _getPayments(): Payments {\n        return guard(\n            this._payments,\n            () => new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized),\n        );\n    }\n\n    private _subscribeToFormValidation(\n        card: Card,\n        observer: Required<SquareV2PaymentInitializeOptions>['onValidationChange'],\n    ): Subscription {\n        const blacklist = ['cardNumber', 'cvv'];\n        const invalidFields = new Set<string>(blacklist);\n        const eventObservables = [\n            'focusClassAdded',\n            'focusClassRemoved',\n            'errorClassAdded',\n            'errorClassRemoved',\n            'cardBrandChanged',\n            'postalCodeChanged',\n        ].map((eventType) => fromEvent(card, eventType as CardInputEventTypes));\n\n        return merge(...eventObservables)\n            .pipe(\n                map((event: SqEvent<CardInputEvent>): boolean => {\n                    const {\n                        detail: {\n                            field,\n                            currentState: { isCompletelyValid },\n                        },\n                    } = event;\n\n                    if (blacklist.includes(field)) {\n                        invalidFields[isCompletelyValid ? 'delete' : 'add'](field);\n                    }\n\n                    return invalidFields.size === 0;\n                }),\n                distinctUntilChanged(),\n            )\n            .subscribe(observer);\n    }\n\n    private _getCard(): Card {\n        return guard(\n            this._card,\n            () => new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized),\n        );\n    }\n\n    private _mapToSquareBillingContact({\n        firstName: givenName,\n        lastName: familyName,\n        address1,\n        address2,\n        city,\n        stateOrProvinceCode: state,\n        postalCode,\n        countryCode,\n        email,\n        phone,\n    }: BillingAddress): BillingContact {\n        return {\n            givenName,\n            familyName,\n            addressLines: [address1, address2],\n            city,\n            state,\n            postalCode,\n            countryCode,\n            email,\n            phone,\n        };\n    }\n\n    private async _chargeVerifyBuyer(token: string): Promise<string> {\n        const { getCheckoutOrThrow, getBillingAddressOrThrow } =\n            this._paymentIntegrationService.getState();\n        const { outstandingBalance, cart } = getCheckoutOrThrow();\n\n        const details: ChargeVerifyBuyerDetails = {\n            amount: outstandingBalance.toString(),\n            billingContact: this._mapToSquareBillingContact(getBillingAddressOrThrow()),\n            currencyCode: cart.currency.code,\n            intent: SquareIntent.CHARGE,\n        };\n\n        const response = await this._getPayments().verifyBuyer(token, details);\n\n        return response ? response.token : '';\n    }\n\n    private async _storeVerifyBuyer(token: string): Promise<string> {\n        const { getBillingAddressOrThrow } = this._paymentIntegrationService.getState();\n\n        const details: StoreVerifyBuyerDetails = {\n            billingContact: this._mapToSquareBillingContact(getBillingAddressOrThrow()),\n            intent: SquareIntent.STORE,\n        };\n\n        const response = await this._getPayments().verifyBuyer(token, details);\n\n        return response ? response.token : '';\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when a method is unable to proceed because the\n * caller has not provided all the arguments according to their requirements,\n * i.e.: if an argument is missing or it is not the expected data type.\n */\nexport default class InvalidArgumentError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Invalid arguments have been provided.');\n\n        this.name = 'InvalidArgumentError';\n        this.type = 'invalid_argument';\n    }\n}\n","import { Response } from '@bigcommerce/request-sender';\n\nimport StandardError from './standard-error';\n\nconst DEFAULT_RESPONSE = {\n    body: {},\n    headers: {},\n    status: 0,\n};\n\n/**\n * Throw this error if we are unable to make a request to the server. It wraps\n * any server response into a JS error object.\n */\nexport default class RequestError<TBody = any> extends StandardError {\n    body: TBody | {};\n    headers: { [key: string]: any };\n    errors: Array<{ code: string; message?: string }>;\n    status: number;\n\n    constructor(\n        response?: Response<TBody | {}>,\n        {\n            message,\n            errors,\n        }: {\n            message?: string;\n            errors?: Array<{ code: string; message?: string }>;\n        } = {},\n    ) {\n        const { body, headers, status } = response || DEFAULT_RESPONSE;\n\n        super(message || 'An unexpected error has occurred.');\n\n        this.name = 'RequestError';\n        this.type = 'request';\n        this.body = body;\n        this.headers = headers;\n        this.status = status;\n        this.errors = errors || [];\n    }\n}\n","import { Response } from '@bigcommerce/request-sender';\n\nimport RequestError from './request-error';\n\n/**\n * Throw this error if we are unable to successfully submit a server request\n * using a payment method because the method has invalid configuration or is in\n * an invalid state.\n */\nexport default class PaymentMethodInvalidError<T = any> extends RequestError<T> {\n    constructor(response?: Response<T>) {\n        super(response, {\n            message: 'There is a problem processing your payment. Please try again later.',\n        });\n\n        this.name = 'PaymentMethodInvalidError';\n        this.type = 'payment_method_invalid';\n    }\n}\n","import InvalidArgumentError from './invalid-argument-error';\n\n/**\n * This error should be thrown when we are unable to submit a payment because\n * the caller has not provided all the required fields, i.e.: if an argument is\n * missing or it is not the expected data type.\n */\nexport default class PaymentArgumentInvalidError extends InvalidArgumentError {\n    constructor(invalidFields?: string[]) {\n        let message = 'Unable to submit payment for the order because the payload is invalid.';\n\n        if (invalidFields) {\n            message = `${message} Make sure the following fields are provided correctly: ${invalidFields.join(\n                ', ',\n            )}.`;\n        }\n\n        super(message);\n\n        this.name = 'PaymentArgumentInvalidError';\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * Throw this error if we are trying to make an order finalization request for a\n * payment method that does not require such procedure.\n */\nexport default class OrderFinalizationNotRequiredError extends StandardError {\n    constructor() {\n        super('The current order does not need to be finalized at this stage.');\n\n        this.name = 'OrderFinalizationNotRequiredError';\n        this.type = 'order_finalization_not_required';\n    }\n}\n","import {\n    InvalidArgumentError,\n    isHostedInstrumentLike,\n    isVaultedInstrument,\n    OrderFinalizationNotRequiredError,\n    OrderRequestBody,\n    PaymentArgumentInvalidError,\n    PaymentInitializeOptions,\n    PaymentIntegrationService,\n    PaymentMethodInvalidError,\n    PaymentStrategy,\n    VaultedInstrument,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport { SquareIntent } from './enums';\nimport { WithSquareV2PaymentInitializeOptions } from './squarev2-payment-initialize-options';\nimport SquareV2PaymentProcessor from './squarev2-payment-processor';\nimport {\n    SquareCreditCardTokens,\n    SquareFormattedVaultedInstrument,\n    SquareInitializationData,\n    SquarePaymentMethodInitializationData,\n} from './types';\n\nexport default class SquareV2PaymentStrategy implements PaymentStrategy {\n    constructor(\n        private _paymentIntegrationService: PaymentIntegrationService,\n        private _squareV2PaymentProcessor: SquareV2PaymentProcessor,\n    ) {}\n\n    async initialize(\n        options?: PaymentInitializeOptions & WithSquareV2PaymentInitializeOptions,\n    ): Promise<void> {\n        if (!options?.squarev2?.containerId) {\n            throw new InvalidArgumentError(\n                'Unable to proceed because \"containerId\" argument is not provided.',\n            );\n        }\n\n        const { methodId, squarev2 } = options;\n        const {\n            config: { testMode },\n            initializationData,\n        } = this._paymentIntegrationService\n            .getState()\n            .getPaymentMethodOrThrow<SquarePaymentMethodInitializationData>(methodId);\n        const { applicationId, locationId } = initializationData || {};\n\n        if (!applicationId) {\n            throw new PaymentMethodInvalidError();\n        }\n\n        await this._squareV2PaymentProcessor.initialize({\n            applicationId,\n            locationId,\n            testMode,\n        });\n        await this._squareV2PaymentProcessor.initializeCard(squarev2);\n    }\n\n    async execute({ payment }: OrderRequestBody): Promise<void> {\n        if (!payment) {\n            throw new PaymentArgumentInvalidError(['payment']);\n        }\n\n        const { methodId, paymentData } = payment;\n        const { shouldSaveInstrument, shouldSetAsDefaultInstrument } = isHostedInstrumentLike(\n            paymentData,\n        )\n            ? paymentData\n            : { shouldSaveInstrument: false, shouldSetAsDefaultInstrument: false };\n\n        await this._paymentIntegrationService.submitOrder();\n\n        const submitPaymentPayload =\n            paymentData && isVaultedInstrument(paymentData)\n                ? await this._getVaultedInstrumentPayload(methodId, paymentData)\n                : await this._getCardPayload(methodId, shouldSaveInstrument);\n\n        await this._paymentIntegrationService.submitPayment({\n            ...payment,\n            paymentData: {\n                formattedPayload: {\n                    ...submitPaymentPayload,\n                    vault_payment_instrument: shouldSaveInstrument || false,\n                    set_as_default_stored_instrument: shouldSetAsDefaultInstrument || false,\n                },\n            },\n        });\n    }\n\n    finalize(): Promise<void> {\n        return Promise.reject(new OrderFinalizationNotRequiredError());\n    }\n\n    deinitialize(): Promise<void> {\n        return this._squareV2PaymentProcessor.deinitialize();\n    }\n\n    private shouldVerify(): boolean {\n        const { features } = this._paymentIntegrationService\n            .getState()\n            .getStoreConfigOrThrow().checkoutSettings;\n\n        return features['PROJECT-3828.add_3ds_support_on_squarev2'];\n    }\n\n    private async _getCardPayload(methodId: string, shouldSaveInstrument?: boolean) {\n        const { getPaymentMethodOrThrow } = this._paymentIntegrationService.getState();\n        const { initializationData } = getPaymentMethodOrThrow<SquareInitializationData>(methodId);\n\n        const cardTokenizationResult = await this._squareV2PaymentProcessor.tokenize();\n\n        if (\n            initializationData && 'isSquareV2ApiV2Enabled' in initializationData\n                ? !initializationData.isSquareV2ApiV2Enabled\n                : !this.shouldVerify()\n        ) {\n            return {\n                credit_card_token: {\n                    token: cardTokenizationResult,\n                },\n            };\n        }\n\n        let tokenData: SquareCreditCardTokens = {\n            nonce: cardTokenizationResult,\n            token: await this._squareV2PaymentProcessor.verifyBuyer(\n                cardTokenizationResult,\n                SquareIntent.CHARGE,\n            ),\n        };\n\n        if (shouldSaveInstrument) {\n            // INFO: additional 'tokenize' is required to verify and save the card\n            // for each 'verifyBuyer' we need to generate new token\n            const tokenForSavingCard = await this._squareV2PaymentProcessor.tokenize();\n\n            tokenData = {\n                ...tokenData,\n                store_card_nonce: tokenForSavingCard,\n                store_card_token: await this._squareV2PaymentProcessor.verifyBuyer(\n                    tokenForSavingCard,\n                    SquareIntent.STORE,\n                ),\n            };\n        }\n\n        return {\n            credit_card_token: {\n                token: JSON.stringify(tokenData),\n            },\n        };\n    }\n\n    private async _getVaultedInstrumentPayload(\n        methodId: string,\n        paymentData: VaultedInstrument,\n    ): Promise<SquareFormattedVaultedInstrument> {\n        const { getPaymentMethodOrThrow } = this._paymentIntegrationService.getState();\n        const { initializationData } = getPaymentMethodOrThrow<SquareInitializationData>(methodId);\n\n        const { instrumentId } = paymentData;\n        const shouldVerify =\n            initializationData && 'isSquareV2ApiV2Enabled' in initializationData\n                ? initializationData.isSquareV2ApiV2Enabled\n                : this.shouldVerify();\n        const verificationToken = shouldVerify\n            ? await this._squareV2PaymentProcessor.verifyBuyer(\n                  await this._getSquareCardIdOrThrow(methodId, instrumentId),\n                  SquareIntent.CHARGE,\n              )\n            : undefined;\n\n        return {\n            bigpay_token: {\n                token: instrumentId,\n                ...(verificationToken && { three_d_secure: { token: verificationToken } }),\n            },\n        };\n    }\n\n    private async _getSquareCardIdOrThrow(methodId: string, instrumentId: string): Promise<string> {\n        const state = await this._paymentIntegrationService.loadPaymentMethod(methodId, {\n            params: { method: methodId, bigpayToken: instrumentId },\n        });\n\n        const { initializationData } =\n            state.getPaymentMethodOrThrow<SquareInitializationData>(methodId);\n        const { cardId } = initializationData || {};\n\n        if (!cardId) {\n            throw new PaymentArgumentInvalidError(['cardId']);\n        }\n\n        return cardId;\n    }\n}\n","import { HostedInstrument } from './payment';\n\nexport default function isHostedInstrumentLike(\n    instrument: unknown,\n): instrument is HostedInstrument {\n    return (\n        typeof instrument === 'object' &&\n        instrument !== null &&\n        (typeof (instrument as HostedInstrument).shouldSaveInstrument === 'undefined' ||\n            typeof (instrument as HostedInstrument).shouldSaveInstrument === 'boolean') &&\n        (typeof (instrument as HostedInstrument).shouldSetAsDefaultInstrument === 'undefined' ||\n            typeof (instrument as HostedInstrument).shouldSetAsDefaultInstrument === 'boolean')\n    );\n}\n","import {\n    FormattedPayload,\n    FormattedVaultedInstrument,\n    HostedVaultedInstrument,\n    PaymentInstrumentPayload,\n    VaultedInstrument,\n} from './payment';\n\nexport default function isVaultedInstrument(\n    instrument: PaymentInstrumentPayload,\n): instrument is VaultedInstrument {\n    return Boolean((instrument as VaultedInstrument).instrumentId);\n}\n\nexport function isHostedVaultedInstrument(\n    instrument: PaymentInstrumentPayload,\n): instrument is HostedVaultedInstrument {\n    return (\n        Boolean((instrument as HostedVaultedInstrument).instrumentId) &&\n        !Object.prototype.hasOwnProperty.call(instrument, 'ccNumber') &&\n        !Object.prototype.hasOwnProperty.call(instrument, 'ccCvv')\n    );\n}\n\nexport function isFormattedVaultedInstrument(\n    instrument: PaymentInstrumentPayload,\n): instrument is FormattedPayload<FormattedVaultedInstrument> {\n    const formattedInstrument = (instrument as FormattedPayload<FormattedVaultedInstrument>)\n        .formattedPayload;\n\n    if (!formattedInstrument) {\n        return false;\n    }\n\n    return (\n        typeof formattedInstrument.bigpay_token === 'string' ||\n        Boolean(formattedInstrument.bigpay_token && formattedInstrument.bigpay_token.token)\n    );\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when the client library of a payment method fails\n * to load, or for some reason, it is inaccessible.\n */\nexport default class PaymentMethodClientUnavailableError extends StandardError {\n    constructor(message?: string) {\n        super(\n            message ||\n                'Unable to proceed because the client library of a payment method is not loaded or ready to be used.',\n        );\n\n        this.name = 'PaymentMethodClientUnavailableError';\n        this.type = 'payment_method_client_unavailable';\n    }\n}\n","import { ScriptLoader } from '@bigcommerce/script-loader';\n\nimport assertSquareV2Window from './is-squarev2-window';\nimport { Square } from './types';\n\nexport enum SquareV2WebPaymentsSdkEnv {\n    LIVE = 'https://web.squarecdn.com/v1/square.js',\n    SANDBOX = 'https://sandbox.web.squarecdn.com/v1/square.js',\n}\n\nexport default class SquareV2ScriptLoader {\n    constructor(private _scriptLoader: ScriptLoader) {}\n\n    async load(testMode = false): Promise<Square> {\n        await this._scriptLoader.loadScript(\n            testMode ? SquareV2WebPaymentsSdkEnv.SANDBOX : SquareV2WebPaymentsSdkEnv.LIVE,\n        );\n\n        assertSquareV2Window(window);\n\n        return window.Square;\n    }\n}\n","import { PaymentMethodClientUnavailableError } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport type { Square } from './types';\n\ninterface SquareV2HostWindow extends Window {\n    Square: Square;\n}\n\nfunction isSquareV2Window(window: Window): window is SquareV2HostWindow {\n    return 'Square' in window;\n}\n\nexport default function assertSquareV2Window(window: Window): asserts window is SquareV2HostWindow {\n    if (!isSquareV2Window(window)) {\n        throw new PaymentMethodClientUnavailableError();\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    PaymentStrategy,\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport SquareV2PaymentProcessor from './squarev2-payment-processor';\nimport SquareV2PaymentStrategy from './squarev2-payment-strategy';\nimport SquareV2ScriptLoader from './squarev2-script-loader';\n\nconst createSquareV2PaymentStrategy: PaymentStrategyFactory<PaymentStrategy> = (\n    paymentIntegrationService,\n) => {\n    return new SquareV2PaymentStrategy(\n        paymentIntegrationService,\n        new SquareV2PaymentProcessor(\n            new SquareV2ScriptLoader(getScriptLoader()),\n            paymentIntegrationService,\n        ),\n    );\n};\n\nexport default toResolvableModule(createSquareV2PaymentStrategy, [{ id: 'squarev2' }]);\n","import ResolvableModule from './resolvable-module';\n\nexport default function toResolvableModule<TModule, TIdentifier>(\n    module: TModule,\n    resolveIds: TIdentifier[],\n): ResolvableModule<TModule, TIdentifier> {\n    return Object.assign(module, { resolveIds });\n}\n"],"names":["NotInitializedErrorType","SquareIntent","StandardError","Error","constructor","message","prototype","super","name","type","Object","setPrototypeOf","this","__proto__","captureStackTrace","stack","PaymentExecuteError","subtype","guard","value","errorFactory","NotInitializedError","CustomerNotInitialized","PaymentNotInitialized","ShippingNotInitialized","SpamProtectionNotInitialized","getErrorMessage","SquareV2PaymentProcessor","_scriptLoader","_paymentIntegrationService","initialize","testMode","applicationId","locationId","square","load","_payments","payments","deinitialize","_formValidationSubscription","unsubscribe","_card","destroy","undefined","initializeCard","containerId","style","onValidationChange","postalCode","getState","getBillingAddress","_getPayments","card","attach","configure","_error","_subscribeToFormValidation","tokenize","result","_getCard","status","token","errorMessage","errors","JSON","stringify","verifyBuyer","intent","CHARGE","_chargeVerifyBuyer","_storeVerifyBuyer","observer","blacklist","invalidFields","Set","eventObservables","map","eventType","fromEvent","merge","pipe","event","detail","field","currentState","isCompletelyValid","includes","size","distinctUntilChanged","subscribe","_mapToSquareBillingContact","firstName","givenName","lastName","familyName","address1","address2","city","stateOrProvinceCode","state","countryCode","email","phone","addressLines","getCheckoutOrThrow","getBillingAddressOrThrow","outstandingBalance","cart","details","amount","toString","billingContact","currencyCode","currency","code","response","STORE","InvalidArgumentError","DEFAULT_RESPONSE","body","headers","RequestError","PaymentMethodInvalidError","PaymentArgumentInvalidError","join","OrderFinalizationNotRequiredError","SquareV2PaymentStrategy","_squareV2PaymentProcessor","options","squarev2","methodId","config","initializationData","getPaymentMethodOrThrow","execute","payment","paymentData","shouldSaveInstrument","shouldSetAsDefaultInstrument","instrument","submitOrder","submitPaymentPayload","Boolean","instrumentId","isVaultedInstrument","_getVaultedInstrumentPayload","_getCardPayload","submitPayment","formattedPayload","vault_payment_instrument","set_as_default_stored_instrument","finalize","Promise","reject","shouldVerify","features","getStoreConfigOrThrow","checkoutSettings","cardTokenizationResult","isSquareV2ApiV2Enabled","credit_card_token","tokenData","nonce","tokenForSavingCard","store_card_nonce","store_card_token","verificationToken","_getSquareCardIdOrThrow","bigpay_token","three_d_secure","loadPaymentMethod","params","method","bigpayToken","cardId","PaymentMethodClientUnavailableError","SquareV2WebPaymentsSdkEnv","SquareV2ScriptLoader","loadScript","SANDBOX","LIVE","window","isSquareV2Window","assertSquareV2Window","Square","module","paymentIntegrationService","getScriptLoader","resolveIds","id","assign"],"sourceRoot":""}