{"version":3,"file":"integrations/afterpay.js","mappings":"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","sources":["webpack://@bigcommerce/checkout-sdk/webpack/bootstrap","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/missing-data-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/standard-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/set-prototype-of.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/invalid-argument-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-argument-invalid-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/order-finalization-not-completed-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/not-initialized-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/request-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/afterpay-integration/src/afterpay-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/is-request-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-client-unavailable-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/afterpay-integration/src/afterpay-script-loader.ts","webpack://@bigcommerce/checkout-sdk/./packages/afterpay-integration/src/is-afterpay-window.ts","webpack://@bigcommerce/checkout-sdk/./packages/afterpay-integration/src/create-afterpay-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/to-resolvable-module.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","import StandardError from './standard-error';\n\nexport enum MissingDataErrorType {\n    MissingBillingAddress,\n    MissingCart,\n    MissingCheckout,\n    MissingConsignments,\n    MissingCustomer,\n    MissingCheckoutConfig,\n    MissingOrder,\n    MissingOrderConfig,\n    MissingOrderId,\n    MissingPayment,\n    MissingPaymentId,\n    MissingPaymentInstrument,\n    MissingPaymentMethod,\n    MissingPaymentRedirectUrl,\n    MissingPaymentStatus,\n    MissingPaymentToken,\n    MissingShippingAddress,\n}\n\n/**\n * Throw this error when data that is expected to exist is missing. Usually it\n * is due to the fact that certain data has not been retrieved from or saved to\n * the server yet. And such data is required to perform certain actions.\n */\nexport default class MissingDataError extends StandardError {\n    constructor(public subtype: MissingDataErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'MissingDataError';\n        this.type = 'missing_data';\n    }\n}\n\nfunction getErrorMessage(type: MissingDataErrorType): string {\n    switch (type) {\n        case MissingDataErrorType.MissingBillingAddress:\n            return 'Unable to proceed because billing address data is unavailable.';\n\n        case MissingDataErrorType.MissingCart:\n            return 'Unable to proceed because cart data is unavailable.';\n\n        case MissingDataErrorType.MissingConsignments:\n            return 'Unable to proceed because consignments data is unavailable.';\n\n        case MissingDataErrorType.MissingCheckout:\n            return 'Unable to proceed because checkout data is unavailable.';\n\n        case MissingDataErrorType.MissingCustomer:\n            return 'Unable to proceed because customer data is unavailable.';\n\n        case MissingDataErrorType.MissingCheckoutConfig:\n        case MissingDataErrorType.MissingOrderConfig:\n            return 'Unable to proceed because configuration data is unavailable.';\n\n        case MissingDataErrorType.MissingOrder:\n            return 'Unable to proceed because order data is unavailable.';\n\n        case MissingDataErrorType.MissingOrderId:\n            return 'Unable to proceed because order ID is unavailable or not generated yet.';\n\n        case MissingDataErrorType.MissingPayment:\n            return 'Unable to proceed because payment data is unavailable.';\n\n        case MissingDataErrorType.MissingPaymentToken:\n            return 'Unable to proceed because the token required to submit a payment is missing.';\n\n        case MissingDataErrorType.MissingPaymentMethod:\n            return 'Unable to proceed because payment method data is unavailable or not properly configured.';\n\n        case MissingDataErrorType.MissingShippingAddress:\n            return 'Unable to proceed because shipping address data is unavailable.';\n\n        default:\n            return 'Unable to proceed because the required data is unavailable.';\n    }\n}\n","import CustomError from './custom-error';\nimport setPrototypeOf from './set-prototype-of';\n\n/**\n * This error type should not be constructed directly. It is a base class for\n * all custom errors thrown in this library.\n */\nexport default abstract class StandardError extends Error implements CustomError {\n    name = 'StandardError';\n    type = 'standard';\n\n    constructor(message?: string) {\n        super(message || 'An unexpected error has occurred.');\n\n        setPrototypeOf(this, new.target.prototype);\n\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, new.target);\n        } else {\n            this.stack = new Error(this.message).stack;\n        }\n    }\n}\n","export default function setPrototypeOf(object: any, prototype: object) {\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(object, prototype);\n    } else {\n        object.__proto__ = prototype;\n    }\n\n    return object;\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when a method is unable to proceed because the\n * caller has not provided all the arguments according to their requirements,\n * i.e.: if an argument is missing or it is not the expected data type.\n */\nexport default class InvalidArgumentError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Invalid arguments have been provided.');\n\n        this.name = 'InvalidArgumentError';\n        this.type = 'invalid_argument';\n    }\n}\n","import InvalidArgumentError from './invalid-argument-error';\n\n/**\n * This error should be thrown when we are unable to submit a payment because\n * the caller has not provided all the required fields, i.e.: if an argument is\n * missing or it is not the expected data type.\n */\nexport default class PaymentArgumentInvalidError extends InvalidArgumentError {\n    constructor(invalidFields?: string[]) {\n        let message = 'Unable to submit payment for the order because the payload is invalid.';\n\n        if (invalidFields) {\n            message = `${message} Make sure the following fields are provided correctly: ${invalidFields.join(\n                ', ',\n            )}.`;\n        }\n\n        super(message);\n\n        this.name = 'PaymentArgumentInvalidError';\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * Throw this error if the order finalization request\n * was not completed successfully.\n */\nexport default class OrderFinalizationNotCompletedError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'The current order could not be finalized successfully');\n\n        this.name = 'OrderFinalizationNotCompletedError';\n        this.type = 'order_finalization_not_completed';\n    }\n}\n","import StandardError from './standard-error';\n\nexport enum NotInitializedErrorType {\n    CheckoutButtonNotInitialized,\n    CustomerNotInitialized,\n    PaymentNotInitialized,\n    ShippingNotInitialized,\n    SpamProtectionNotInitialized,\n}\n\n/**\n * Throw this error if a method requires a certain initialization call to be\n * made first. Some objects can be constructed but they cannot be used until a\n * separate initialization call is made.\n */\nexport default class NotInitializedError extends StandardError {\n    constructor(public subtype: NotInitializedErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'NotInitializedError';\n        this.type = 'not_initialized';\n    }\n}\n\nfunction getErrorMessage(type: NotInitializedErrorType): string {\n    switch (type) {\n        case NotInitializedErrorType.CustomerNotInitialized:\n            return 'Unable to proceed because the customer step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.PaymentNotInitialized:\n            return 'Unable to proceed because the payment step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.ShippingNotInitialized:\n            return 'Unable to proceed because the shipping step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.SpamProtectionNotInitialized:\n            return 'Unable to proceed because the checkout spam protection has not been initialized.';\n\n        default:\n            return 'Unable to proceed because the required component has not been initialized.';\n    }\n}\n","import { Response } from '@bigcommerce/request-sender';\n\nimport StandardError from './standard-error';\n\nconst DEFAULT_RESPONSE = {\n    body: {},\n    headers: {},\n    status: 0,\n};\n\n/**\n * Throw this error if we are unable to make a request to the server. It wraps\n * any server response into a JS error object.\n */\nexport default class RequestError<TBody = any> extends StandardError {\n    body: TBody | {};\n    headers: { [key: string]: any };\n    errors: Array<{ code: string; message?: string }>;\n    status: number;\n\n    constructor(\n        response?: Response<TBody | {}>,\n        {\n            message,\n            errors,\n        }: {\n            message?: string;\n            errors?: Array<{ code: string; message?: string }>;\n        } = {},\n    ) {\n        const { body, headers, status } = response || DEFAULT_RESPONSE;\n\n        super(message || 'An unexpected error has occurred.');\n\n        this.name = 'RequestError';\n        this.type = 'request';\n        this.body = body;\n        this.headers = headers;\n        this.status = status;\n        this.errors = errors || [];\n    }\n}\n","import {\n    InvalidArgumentError,\n    isRequestError,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    OrderFinalizationNotCompletedError,\n    OrderRequestBody,\n    PaymentArgumentInvalidError,\n    PaymentInitializeOptions,\n    PaymentIntegrationSelectors,\n    PaymentIntegrationService,\n    PaymentMethod,\n    PaymentRequestOptions,\n    PaymentStrategy,\n    RequestError,\n    RequestOptions,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport AfterpayScriptLoader from './afterpay-script-loader';\nimport AfterpaySdk from './afterpay-sdk';\n\nexport default class AfterpayPaymentStrategy implements PaymentStrategy {\n    private _afterpaySdk?: AfterpaySdk;\n\n    constructor(\n        private _paymentIntegrationService: PaymentIntegrationService,\n        private _afterpayScriptLoader: AfterpayScriptLoader,\n    ) {}\n\n    async initialize(options: PaymentInitializeOptions): Promise<void> {\n        const state = this._paymentIntegrationService.getState();\n        const paymentMethod = state.getPaymentMethod(options.methodId, options.gatewayId);\n        const currencyCode = state.getCart()?.currency.code || '';\n        const countryCode = this._mapCurrencyToISO2(currencyCode);\n\n        if (!paymentMethod) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        this._afterpaySdk = await this._afterpayScriptLoader.load(paymentMethod, countryCode);\n    }\n\n    deinitialize(): Promise<void> {\n        if (this._afterpaySdk) {\n            this._afterpaySdk = undefined;\n        }\n\n        return Promise.resolve();\n    }\n\n    async execute(payload: OrderRequestBody, options?: PaymentRequestOptions): Promise<void> {\n        if (!payload.payment) {\n            throw new PaymentArgumentInvalidError(['payment.gatewayId', 'payment.methodId']);\n        }\n\n        const { gatewayId, methodId } = payload.payment;\n\n        if (!gatewayId || !methodId) {\n            throw new PaymentArgumentInvalidError(['payment.gatewayId', 'payment.methodId']);\n        }\n\n        const { useStoreCredit } = payload;\n\n        if (useStoreCredit !== undefined) {\n            await this._paymentIntegrationService.applyStoreCredit(useStoreCredit);\n        }\n\n        await this._loadPaymentMethod(gatewayId, methodId, options);\n\n        const state = this._paymentIntegrationService.getState();\n\n        await this._paymentIntegrationService.validateCheckout(state.getCheckout(), options);\n\n        const currencyCode = state.getCart()?.currency.code || '';\n        const countryCode = this._mapCurrencyToISO2(currencyCode);\n\n        this._redirectToAfterpay(countryCode, state.getPaymentMethod(methodId, gatewayId));\n\n        // Afterpay will handle the rest of the flow so return a promise that doesn't really resolve\n        // eslint-disable-next-line @typescript-eslint/no-empty-function\n        return new Promise<never>(() => {});\n    }\n\n    async finalize(options: PaymentRequestOptions): Promise<void> {\n        const state = this._paymentIntegrationService.getState();\n        const payment = state.getPaymentId();\n        const config = state.getContextConfig();\n\n        if (!payment) {\n            throw new MissingDataError(MissingDataErrorType.MissingCheckout);\n        }\n\n        if (!config?.payment.token) {\n            throw new MissingDataError(MissingDataErrorType.MissingCheckoutConfig);\n        }\n\n        const paymentPayload = {\n            methodId: payment.providerId,\n            paymentData: { nonce: config.payment.token },\n        };\n\n        await this._paymentIntegrationService.submitOrder({}, options);\n\n        try {\n            await this._paymentIntegrationService.submitPayment(paymentPayload);\n        } catch (error) {\n            await this._paymentIntegrationService.forgetCheckout(payment.providerId);\n            await this._paymentIntegrationService.loadPaymentMethods();\n\n            if (isRequestError(error)) {\n                // eslint-disable-next-line @typescript-eslint/no-unsafe-argument,@typescript-eslint/no-unsafe-member-access\n                throw new OrderFinalizationNotCompletedError(error.body?.errors?.[0]?.message);\n            }\n        }\n    }\n\n    private _redirectToAfterpay(countryCode: string, paymentMethod?: PaymentMethod): void {\n        if (!this._afterpaySdk || !paymentMethod?.clientToken) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        this._afterpaySdk.initialize({ countryCode });\n        this._afterpaySdk.redirect({ token: paymentMethod.clientToken });\n    }\n\n    private _mapCurrencyToISO2(currencyCode: string): string {\n        const countryByCurrency: { [key: string]: string } = {\n            AUD: 'AU',\n            NZD: 'NZ',\n            CAD: 'CA',\n            USD: 'US',\n        };\n\n        return countryByCurrency[currencyCode] || 'AU';\n    }\n\n    private async _loadPaymentMethod(\n        gatewayId: string,\n        methodId: string,\n        options?: RequestOptions,\n    ): Promise<PaymentIntegrationSelectors> {\n        try {\n            return await this._paymentIntegrationService.loadPaymentMethod(gatewayId, {\n                ...options,\n                params: { ...options?.params, method: methodId },\n            });\n        } catch (error) {\n            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n            if (error instanceof RequestError && error.body?.status === 422) {\n                throw new InvalidArgumentError(\n                    \"Afterpay can't process your payment for this order, please try another payment method\",\n                );\n            }\n\n            throw error;\n        }\n    }\n}\n","import RequestError from './request-error';\n\n// Have to use `as` https://stackoverflow.com/questions/73987044/typeguarding-an-unknown-nested-object should be fixed in 4.8+\nconst isRequestError = (error: unknown): error is RequestError => {\n    return typeof error === 'object' && error !== null && 'body' in error;\n};\n\nexport default isRequestError;\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when the client library of a payment method fails\n * to load, or for some reason, it is inaccessible.\n */\nexport default class PaymentMethodClientUnavailableError extends StandardError {\n    constructor(message?: string) {\n        super(\n            message ||\n                'Unable to proceed because the client library of a payment method is not loaded or ready to be used.',\n        );\n\n        this.name = 'PaymentMethodClientUnavailableError';\n        this.type = 'payment_method_client_unavailable';\n    }\n}\n","import { ScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    PaymentMethod,\n    PaymentMethodClientUnavailableError,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport AfterpaySdk from './afterpay-sdk';\nimport isAfterpayWindow from './is-afterpay-window';\n\nenum SCRIPTS_DEFAULT {\n    PROD = '//portal.afterpay.com/afterpay-async.js',\n    SANDBOX = '//portal-sandbox.afterpay.com/afterpay-async.js',\n}\n\nenum SCRIPTS_US {\n    PROD = '//portal.afterpay.com/afterpay-async.js',\n    SANDBOX = '//portal.sandbox.afterpay.com/afterpay-async.js',\n}\n\n/** Class responsible for loading the Afterpay SDK */\nexport default class AfterpayScriptLoader {\n    constructor(private _scriptLoader: ScriptLoader) {}\n\n    /**\n     * Loads the appropriate Afterpay SDK depending on the payment method data.\n     *\n     * @param {PaymentMethod} method the payment method data\n     */\n    async load(method: PaymentMethod, countryCode: string): Promise<AfterpaySdk> {\n        const testMode = method.config.testMode || false;\n        const scriptURI = this._getScriptURI(countryCode, testMode);\n\n        return this._scriptLoader.loadScript(scriptURI).then(() => {\n            if (!isAfterpayWindow(window)) {\n                throw new PaymentMethodClientUnavailableError();\n            }\n\n            return window.AfterPay;\n        });\n    }\n\n    private _getScriptURI(countryCode: string, testMode: boolean): string {\n        if (countryCode === 'US') {\n            return testMode ? SCRIPTS_US.SANDBOX : SCRIPTS_US.PROD;\n        }\n\n        return testMode ? SCRIPTS_DEFAULT.SANDBOX : SCRIPTS_DEFAULT.PROD;\n    }\n}\n","import AfterpayWindow from './afterpay-window';\n\nexport default function isAfterpayWindow(window: Window): window is AfterpayWindow {\n    return 'AfterPay' in window;\n}\n","import { createScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport AfterpayPaymentStrategy from './afterpay-payment-strategy';\nimport AfterpayScriptLoader from './afterpay-script-loader';\n\nconst createAfterpayPaymentStrategy: PaymentStrategyFactory<AfterpayPaymentStrategy> = (\n    paymentIntegrationService,\n) => {\n    return new AfterpayPaymentStrategy(\n        paymentIntegrationService,\n        new AfterpayScriptLoader(createScriptLoader()),\n    );\n};\n\nexport default toResolvableModule(createAfterpayPaymentStrategy, [\n    { gateway: 'afterpay' },\n    { id: 'afterpay' },\n]);\n","import ResolvableModule from './resolvable-module';\n\nexport default function toResolvableModule<TModule, TIdentifier>(\n    module: TModule,\n    resolveIds: TIdentifier[],\n): ResolvableModule<TModule, TIdentifier> {\n    return Object.assign(module, { resolveIds });\n}\n"],"names":["MissingDataErrorType","StandardError","Error","constructor","message","prototype","super","name","type","Object","setPrototypeOf","this","__proto__","captureStackTrace","stack","MissingDataError","subtype","MissingBillingAddress","MissingCart","MissingConsignments","MissingCheckout","MissingCustomer","MissingCheckoutConfig","MissingOrderConfig","MissingOrder","MissingOrderId","MissingPayment","MissingPaymentToken","MissingPaymentMethod","MissingShippingAddress","getErrorMessage","InvalidArgumentError","PaymentArgumentInvalidError","invalidFields","join","OrderFinalizationNotCompletedError","NotInitializedErrorType","NotInitializedError","CustomerNotInitialized","PaymentNotInitialized","ShippingNotInitialized","SpamProtectionNotInitialized","DEFAULT_RESPONSE","body","headers","status","RequestError","response","errors","AfterpayPaymentStrategy","_paymentIntegrationService","_afterpayScriptLoader","initialize","options","state","getState","paymentMethod","getPaymentMethod","methodId","gatewayId","currencyCode","getCart","currency","code","countryCode","_mapCurrencyToISO2","_afterpaySdk","load","deinitialize","undefined","Promise","resolve","execute","payload","payment","useStoreCredit","applyStoreCredit","_loadPaymentMethod","validateCheckout","getCheckout","_redirectToAfterpay","finalize","getPaymentId","config","getContextConfig","token","paymentPayload","providerId","paymentData","nonce","submitOrder","submitPayment","error","forgetCheckout","loadPaymentMethods","clientToken","redirect","AUD","NZD","CAD","USD","loadPaymentMethod","params","method","PaymentMethodClientUnavailableError","SCRIPTS_DEFAULT","SCRIPTS_US","AfterpayScriptLoader","_scriptLoader","testMode","scriptURI","_getScriptURI","loadScript","then","window","isAfterpayWindow","AfterPay","SANDBOX","PROD","module","paymentIntegrationService","createScriptLoader","resolveIds","gateway","id","assign"],"sourceRoot":""}