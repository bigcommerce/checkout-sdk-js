{"version":3,"file":"integrations/bolt.js","mappings":"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","sources":["webpack://@bigcommerce/checkout-sdk/webpack/bootstrap","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/missing-data-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/not-initialized-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/to-resolvable-module.ts","webpack://@bigcommerce/checkout-sdk/webpack/runtime/define property getters","webpack://@bigcommerce/checkout-sdk/webpack/runtime/hasOwnProperty shorthand","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/standard-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/set-prototype-of.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/invalid-argument-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-failed-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/request-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-invalid-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/bolt.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/bolt-customer-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/custom-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-client-unavailable-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/bolt-script-loader.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/create-bolt-customer-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/analytics/src/analytics-extra-items-manager.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/order-finalization-not-required-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-argument-invalid-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/payment-method-cancelled-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/payment/is-with-account-creation.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/bolt-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/bolt-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/is-bolt-payment-data.ts","webpack://@bigcommerce/checkout-sdk/./packages/analytics/src/is-analytics-step-tracker-window.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/create-bolt-payment-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/payment-integration-api/src/errors/not-implemented-error.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/bolt-button-strategy.ts","webpack://@bigcommerce/checkout-sdk/./packages/bolt-integration/src/create-bolt-button-strategy.ts"],"sourcesContent":["// The require scope\nvar __webpack_require__ = {};\n\n","import StandardError from './standard-error';\n\nexport enum MissingDataErrorType {\n    MissingBillingAddress,\n    MissingCart,\n    MissingCheckout,\n    MissingConsignments,\n    MissingCustomer,\n    MissingCheckoutConfig,\n    MissingOrder,\n    MissingOrderConfig,\n    MissingOrderId,\n    MissingPayment,\n    MissingPaymentId,\n    MissingPaymentInstrument,\n    MissingPaymentMethod,\n    MissingPaymentRedirectUrl,\n    MissingPaymentStatus,\n    MissingPaymentToken,\n    MissingShippingAddress,\n}\n\n/**\n * Throw this error when data that is expected to exist is missing. Usually it\n * is due to the fact that certain data has not been retrieved from or saved to\n * the server yet. And such data is required to perform certain actions.\n */\nexport default class MissingDataError extends StandardError {\n    constructor(public subtype: MissingDataErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'MissingDataError';\n        this.type = 'missing_data';\n    }\n}\n\nfunction getErrorMessage(type: MissingDataErrorType): string {\n    switch (type) {\n        case MissingDataErrorType.MissingBillingAddress:\n            return 'Unable to proceed because billing address data is unavailable.';\n\n        case MissingDataErrorType.MissingCart:\n            return 'Unable to proceed because cart data is unavailable.';\n\n        case MissingDataErrorType.MissingConsignments:\n            return 'Unable to proceed because consignments data is unavailable.';\n\n        case MissingDataErrorType.MissingCheckout:\n            return 'Unable to proceed because checkout data is unavailable.';\n\n        case MissingDataErrorType.MissingCustomer:\n            return 'Unable to proceed because customer data is unavailable.';\n\n        case MissingDataErrorType.MissingCheckoutConfig:\n        case MissingDataErrorType.MissingOrderConfig:\n            return 'Unable to proceed because configuration data is unavailable.';\n\n        case MissingDataErrorType.MissingOrder:\n            return 'Unable to proceed because order data is unavailable.';\n\n        case MissingDataErrorType.MissingOrderId:\n            return 'Unable to proceed because order ID is unavailable or not generated yet.';\n\n        case MissingDataErrorType.MissingPayment:\n            return 'Unable to proceed because payment data is unavailable.';\n\n        case MissingDataErrorType.MissingPaymentToken:\n            return 'Unable to proceed because the token required to submit a payment is missing.';\n\n        case MissingDataErrorType.MissingPaymentMethod:\n            return 'Unable to proceed because payment method data is unavailable or not properly configured.';\n\n        case MissingDataErrorType.MissingShippingAddress:\n            return 'Unable to proceed because shipping address data is unavailable.';\n\n        default:\n            return 'Unable to proceed because the required data is unavailable.';\n    }\n}\n","import StandardError from './standard-error';\n\nexport enum NotInitializedErrorType {\n    CheckoutButtonNotInitialized,\n    CustomerNotInitialized,\n    PaymentNotInitialized,\n    ShippingNotInitialized,\n    SpamProtectionNotInitialized,\n}\n\n/**\n * Throw this error if a method requires a certain initialization call to be\n * made first. Some objects can be constructed but they cannot be used until a\n * separate initialization call is made.\n */\nexport default class NotInitializedError extends StandardError {\n    constructor(public subtype: NotInitializedErrorType) {\n        super(getErrorMessage(subtype));\n\n        this.name = 'NotInitializedError';\n        this.type = 'not_initialized';\n    }\n}\n\nfunction getErrorMessage(type: NotInitializedErrorType): string {\n    switch (type) {\n        case NotInitializedErrorType.CustomerNotInitialized:\n            return 'Unable to proceed because the customer step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.PaymentNotInitialized:\n            return 'Unable to proceed because the payment step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.ShippingNotInitialized:\n            return 'Unable to proceed because the shipping step of checkout has not been initialized.';\n\n        case NotInitializedErrorType.SpamProtectionNotInitialized:\n            return 'Unable to proceed because the checkout spam protection has not been initialized.';\n\n        default:\n            return 'Unable to proceed because the required component has not been initialized.';\n    }\n}\n","import ResolvableModule from './resolvable-module';\n\nexport default function toResolvableModule<TModule, TIdentifier>(\n    module: TModule,\n    resolveIds: TIdentifier[],\n): ResolvableModule<TModule, TIdentifier> {\n    return Object.assign(module, { resolveIds });\n}\n","// define getter functions for harmony exports\n__webpack_require__.d = (exports, definition) => {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))","import CustomError from './custom-error';\nimport setPrototypeOf from './set-prototype-of';\n\n/**\n * This error type should not be constructed directly. It is a base class for\n * all custom errors thrown in this library.\n */\nexport default abstract class StandardError extends Error implements CustomError {\n    name = 'StandardError';\n    type = 'standard';\n\n    constructor(message?: string) {\n        super(message || 'An unexpected error has occurred.');\n\n        setPrototypeOf(this, new.target.prototype);\n\n        if (typeof Error.captureStackTrace === 'function') {\n            Error.captureStackTrace(this, new.target);\n        } else {\n            this.stack = new Error(this.message).stack;\n        }\n    }\n}\n","export default function setPrototypeOf(object: any, prototype: object) {\n    if (Object.setPrototypeOf) {\n        Object.setPrototypeOf(object, prototype);\n    } else {\n        object.__proto__ = prototype;\n    }\n\n    return object;\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when a method is unable to proceed because the\n * caller has not provided all the arguments according to their requirements,\n * i.e.: if an argument is missing or it is not the expected data type.\n */\nexport default class InvalidArgumentError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Invalid arguments have been provided.');\n\n        this.name = 'InvalidArgumentError';\n        this.type = 'invalid_argument';\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when a payment method experiences some kind of\n * failure (i.e.: its client library returns a rejected promise). And there is\n * no other error type that is more specific than this one.\n */\nexport default class PaymentMethodFailedError extends StandardError {\n    constructor(message?: string) {\n        super(\n            message ||\n                'Unable to proceed because the client library of a payment method has thrown an unexpected error.',\n        );\n\n        this.name = 'PaymentMethodFailedError';\n        this.type = 'payment_method_client_invalid';\n    }\n}\n","import { Response } from '@bigcommerce/request-sender';\n\nimport StandardError from './standard-error';\n\nconst DEFAULT_RESPONSE = {\n    body: {},\n    headers: {},\n    status: 0,\n};\n\n/**\n * Throw this error if we are unable to make a request to the server. It wraps\n * any server response into a JS error object.\n */\nexport default class RequestError<TBody = any> extends StandardError {\n    body: TBody | {};\n    headers: { [key: string]: any };\n    errors: Array<{ code: string; message?: string }>;\n    status: number;\n\n    constructor(\n        response?: Response<TBody | {}>,\n        {\n            message,\n            errors,\n        }: {\n            message?: string;\n            errors?: Array<{ code: string; message?: string }>;\n        } = {},\n    ) {\n        const { body, headers, status } = response || DEFAULT_RESPONSE;\n\n        super(message || 'An unexpected error has occurred.');\n\n        this.name = 'RequestError';\n        this.type = 'request';\n        this.body = body;\n        this.headers = headers;\n        this.status = status;\n        this.errors = errors || [];\n    }\n}\n","import { Response } from '@bigcommerce/request-sender';\n\nimport RequestError from './request-error';\n\n/**\n * Throw this error if we are unable to successfully submit a server request\n * using a payment method because the method has invalid configuration or is in\n * an invalid state.\n */\nexport default class PaymentMethodInvalidError<T = any> extends RequestError<T> {\n    constructor(response?: Response<T>) {\n        super(response, {\n            message: 'There is a problem processing your payment. Please try again later.',\n        });\n\n        this.name = 'PaymentMethodInvalidError';\n        this.type = 'payment_method_invalid';\n    }\n}\n","import {\n    BuyNowCartRequestBody,\n    NonceInstrument,\n    PaymentMethod,\n    WithAccountCreation,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nexport interface BoltHostWindow extends Window {\n    BoltCheckout?: BoltCheckout;\n    BoltConnect?: BoltConnect;\n    Bolt?(publicKey: string): BoltEmbedded;\n}\n\nexport interface BoltCheckout {\n    configure(cart: BoltCart, hints: Record<string, never>, callbacks?: BoltCallbacks): BoltClient;\n    hasBoltAccount(email: string): Promise<boolean>;\n    getTransactionReference(): Promise<string | undefined>;\n    openCheckout(email: string, callbacks?: BoltOpenCheckoutCallbacks): Promise<void>;\n    setClientCustomCallbacks(callbacks: BoltCallbacks): void;\n    setOrderId(orderId: number): Promise<void>;\n}\n\nexport interface BoltConnect {\n    setupProductPageCheckout?(): void;\n}\n\nexport interface BoltOpenCheckoutCallbacks {\n    close?(): void;\n}\n\nexport interface BoltEmbeddedOptions {\n    styles: { backgroundColor: string };\n    renderSeparateFields?: boolean;\n}\n\nexport interface BoltEmbedded {\n    create(name: string, options?: BoltEmbeddedOptions): BoltEmbededField;\n}\n\nexport interface BoltEmbededField {\n    mount(element: string): void;\n    unmount(): void;\n    tokenize(): Promise<BoltEmbeddedTokenize | Error>;\n}\n\nexport interface BoltDeveloperModeParams {\n    developerMode: BoltDeveloperMode;\n    developerDomain: string;\n}\n\nexport enum BoltDeveloperMode {\n    SandboxMode = 'bolt_sandbox',\n    StagingMode = 'bolt_staging',\n    DevelopmentMode = 'bolt_development',\n}\n\nexport interface BoltClient {\n    open(): void;\n}\n\nexport interface BoltCart {\n    orderToken: string;\n}\n\nexport interface BoltCallbacks {\n    check?(): boolean;\n    onCheckoutStart?(): void;\n    onPaymentSubmit?(): void;\n    success(transaction: BoltTransaction, callback: () => void): void;\n    close?(): void;\n}\n\nexport interface BoltTransaction {\n    id: string;\n    type: string;\n    processor: string;\n    date: number;\n    reference: string;\n    status: string;\n    authorization: BoltAuthorization;\n}\n\nexport interface BoltAuthorization {\n    status: string;\n    reason: string;\n}\n\nexport interface BoltEmbeddedTokenize {\n    bin: string;\n    expiration: string;\n    last4: string;\n    postal_code?: string;\n    token: string;\n    token_type: string;\n}\n\nexport interface BoltPaymentMethod extends PaymentMethod {\n    initializationData?: BoltInitializationData;\n}\n\nexport interface BoltInitializationData {\n    publishableKey: string;\n    developerConfig: BoltDeveloperModeParams;\n    embeddedOneClickEnabled: boolean;\n}\n\nexport type BoltPaymentData = WithAccountCreation & NonceInstrument;\n\nexport interface BoltBuyNowInitializeOptions {\n    storefrontApiToken?: string;\n    getBuyNowCartRequestBody(): BuyNowCartRequestBody;\n}\n\nexport enum StyleButtonSize {\n    Small = 'small',\n    Medium = 'medium',\n    Large = 'large',\n}\n\nexport enum StyleButtonShape {\n    Pill = 'pill',\n    Rect = 'rect',\n}\n\nexport interface BoltButtonStyleOptions {\n    shape?: StyleButtonShape;\n    size?: StyleButtonSize;\n}\n","import { noop } from 'rxjs';\n\nimport {\n    CheckoutPaymentMethodExecutedOptions,\n    CustomerCredentials,\n    CustomerInitializeOptions,\n    CustomerStrategy,\n    ExecutePaymentMethodCheckoutOptions,\n    InvalidArgumentError,\n    isCustomError,\n    MissingDataError,\n    MissingDataErrorType,\n    NotInitializedError,\n    NotInitializedErrorType,\n    PaymentIntegrationService,\n    PaymentMethod,\n    PaymentMethodFailedError,\n    PaymentMethodInvalidError,\n    RequestOptions,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport { BoltCheckout, BoltHostWindow, BoltInitializationData } from './bolt';\nimport { WithBoltCustomerInitializeOptions } from './bolt-customer-initialize-options';\nimport BoltScriptLoader from './bolt-script-loader';\n\nexport default class BoltCustomerStrategy implements CustomerStrategy {\n    private boltHostWindow: BoltHostWindow = window;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private boltScriptLoader: BoltScriptLoader,\n    ) {}\n\n    async initialize(\n        options: CustomerInitializeOptions & WithBoltCustomerInitializeOptions,\n    ): Promise<void> {\n        const { methodId, bolt } = options;\n        const { onInit } = bolt || {};\n\n        if (!methodId) {\n            throw new InvalidArgumentError(\n                'Unable to proceed because \"methodId\" argument is not provided.',\n            );\n        }\n\n        await this.paymentIntegrationService.loadPaymentMethod(methodId);\n\n        const paymentMethod: PaymentMethod<BoltInitializationData> = this.paymentIntegrationService\n            .getState()\n            .getPaymentMethodOrThrow<BoltInitializationData>(methodId);\n\n        if (!paymentMethod.initializationData?.publishableKey) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        const { developerConfig, publishableKey } = paymentMethod.initializationData;\n\n        await this.boltScriptLoader.loadBoltClient(\n            publishableKey,\n            paymentMethod.config.testMode,\n            developerConfig,\n        );\n\n        if (onInit && typeof onInit === 'function') {\n            const email = this.getCustomerEmail();\n            const hasBoltAccount = await this.hasBoltAccount(email);\n\n            onInit(hasBoltAccount, email);\n        }\n    }\n\n    deinitialize(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    async signIn(credentials: CustomerCredentials, options?: RequestOptions): Promise<void> {\n        await this.paymentIntegrationService.signInCustomer(credentials, options);\n\n        return Promise.resolve();\n    }\n\n    async signOut(options?: RequestOptions): Promise<void> {\n        await this.paymentIntegrationService.signOutCustomer(options);\n\n        return Promise.resolve();\n    }\n\n    async executePaymentMethodCheckout(\n        options?: ExecutePaymentMethodCheckoutOptions,\n    ): Promise<void> {\n        const {\n            continueWithCheckoutCallback = noop,\n            checkoutPaymentMethodExecuted,\n            methodId,\n        } = options || {};\n        const email = this.getCustomerEmail();\n\n        if (!methodId) {\n            throw new InvalidArgumentError(\n                'Unable to proceed because \"methodId\" argument is not provided.',\n            );\n        }\n\n        if (typeof continueWithCheckoutCallback !== 'function') {\n            throw new InvalidArgumentError(\n                'Unable to proceed because \"continueWithCheckoutCallback\" argument is not provided and it must be a function.',\n            );\n        }\n\n        if (!email) {\n            continueWithCheckoutCallback();\n\n            return;\n        }\n\n        return this.openBoltCheckoutModalOrThrow(\n            email,\n            methodId,\n            continueWithCheckoutCallback,\n            checkoutPaymentMethodExecuted,\n        );\n    }\n\n    private async openBoltCheckoutModalOrThrow(\n        email: string,\n        methodId: string,\n        continueWithCheckoutCallback: () => void,\n        checkoutPaymentMethodExecuted?: (payload: CheckoutPaymentMethodExecutedOptions) => void,\n    ): Promise<void> {\n        const boltClient = this.getBoltClientOrThrow();\n        const paymentMethod = this.paymentIntegrationService\n            .getState()\n            .getPaymentMethod<BoltInitializationData>(methodId);\n\n        try {\n            if (paymentMethod?.initializationData?.embeddedOneClickEnabled) {\n                const hasBoltAccount = await this.hasBoltAccount(email);\n\n                if (hasBoltAccount) {\n                    const callbacks = {\n                        close: () => {\n                            continueWithCheckoutCallback();\n                        },\n                    };\n\n                    await boltClient.openCheckout(email, callbacks);\n                } else {\n                    continueWithCheckoutCallback();\n                }\n\n                if (typeof checkoutPaymentMethodExecuted === 'function') {\n                    checkoutPaymentMethodExecuted({ hasBoltAccount });\n                }\n            } else {\n                continueWithCheckoutCallback();\n            }\n        } catch (error) {\n            if (\n                isCustomError(error) &&\n                error.name !== 'MissingDataError' &&\n                error.name !== 'NotInitializedError'\n            ) {\n                throw new PaymentMethodFailedError(error.message);\n            }\n\n            throw error;\n        }\n    }\n\n    private getBoltClientOrThrow(): BoltCheckout {\n        const boltClient = this.boltHostWindow.BoltCheckout;\n\n        if (!boltClient) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        return boltClient;\n    }\n\n    private async hasBoltAccount(email: string) {\n        const boltClient = this.getBoltClientOrThrow();\n\n        try {\n            return await boltClient.hasBoltAccount(email);\n        } catch {\n            throw new PaymentMethodInvalidError();\n        }\n    }\n\n    private getCustomerEmail() {\n        const state = this.paymentIntegrationService.getState();\n        const customer = state.getCustomer();\n        const billingAddress = state.getBillingAddress();\n\n        return customer?.email || billingAddress?.email || '';\n    }\n}\n","export default interface CustomError extends Error {\n    message: string;\n    type: string;\n    subtype?: string;\n}\n\nexport function isCustomError(error: any): error is CustomError {\n    return (\n        typeof error.message === 'string' &&\n        typeof error.type === 'string' &&\n        (typeof error.subtype === 'string' || !error.subtype) &&\n        error instanceof Error\n    );\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when the client library of a payment method fails\n * to load, or for some reason, it is inaccessible.\n */\nexport default class PaymentMethodClientUnavailableError extends StandardError {\n    constructor(message?: string) {\n        super(\n            message ||\n                'Unable to proceed because the client library of a payment method is not loaded or ready to be used.',\n        );\n\n        this.name = 'PaymentMethodClientUnavailableError';\n        this.type = 'payment_method_client_unavailable';\n    }\n}\n","import { LoadScriptOptions, ScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    InvalidArgumentError,\n    PaymentMethodClientUnavailableError,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport {\n    BoltCheckout,\n    BoltDeveloperMode,\n    BoltDeveloperModeParams,\n    BoltEmbedded,\n    BoltHostWindow,\n} from './bolt';\n\nexport default class BoltScriptLoader {\n    constructor(\n        private scriptLoader: ScriptLoader,\n        public boltHostWindow: BoltHostWindow = window,\n    ) {}\n\n    async loadBoltClient(\n        publishableKey?: string,\n        testMode?: boolean,\n        developerModeParams?: BoltDeveloperModeParams,\n        cartId?: string,\n        storefrontApiToken?: string,\n    ): Promise<BoltCheckout> {\n        if (this.boltHostWindow.BoltCheckout) {\n            return this.boltHostWindow.BoltCheckout;\n        }\n\n        if (!publishableKey) {\n            throw new InvalidArgumentError(\n                'Unable to initialize payment because \"publishableKey\" argument is not provided.',\n            );\n        }\n\n        await this.scriptLoader.loadScript(\n            `//${this.getDomainURL(!!testMode, developerModeParams)}/connect-bigcommerce.js`,\n            this.getScriptOptions('bolt-connect', publishableKey, cartId, storefrontApiToken),\n        );\n        await this.scriptLoader.loadScript(\n            `//${this.getDomainURL(!!testMode, developerModeParams)}/track.js`,\n            this.getScriptOptions('bolt-track', publishableKey),\n        );\n\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (!this.boltHostWindow.BoltCheckout) {\n            throw new PaymentMethodClientUnavailableError();\n        }\n\n        return this.boltHostWindow.BoltCheckout;\n    }\n\n    async loadBoltEmbedded(\n        publishableKey: string,\n        testMode?: boolean,\n        developerModeParams?: BoltDeveloperModeParams,\n    ): Promise<BoltEmbedded> {\n        const options: LoadScriptOptions = {\n            async: true,\n            attributes: {\n                id: 'bolt-embedded',\n            },\n        };\n\n        await this.scriptLoader.loadScript(\n            `//${this.getDomainURL(!!testMode, developerModeParams)}/embed.js`,\n            options,\n        );\n\n        if (!this.boltHostWindow.Bolt) {\n            throw new PaymentMethodClientUnavailableError();\n        }\n\n        return this.boltHostWindow.Bolt(publishableKey);\n    }\n\n    getDomainURL(testMode: boolean, developerModeParams?: BoltDeveloperModeParams): string {\n        if (!testMode) {\n            return 'connect.bolt.com';\n        }\n\n        if (developerModeParams) {\n            switch (developerModeParams.developerMode) {\n                case BoltDeveloperMode.StagingMode:\n                    return 'connect-staging.bolt.com';\n\n                case BoltDeveloperMode.DevelopmentMode:\n                    return `connect.${developerModeParams.developerDomain}`;\n            }\n        }\n\n        return 'connect-sandbox.bolt.com';\n    }\n\n    private getScriptOptions(\n        id: string,\n        publishableKey: string,\n        cartId?: string,\n        storefrontApiToken?: string,\n    ): LoadScriptOptions {\n        return {\n            async: true,\n            attributes: {\n                id,\n                'data-publishable-key': publishableKey,\n                ...(cartId && { 'data-shopping-cart-id': cartId }),\n                ...(storefrontApiToken && { 'data-storefront-api-token': storefrontApiToken }),\n            },\n        };\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    CustomerStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport BoltCustomerStrategy from './bolt-customer-strategy';\nimport BoltScriptLoader from './bolt-script-loader';\n\nconst createBoltCustomerStrategy: CustomerStrategyFactory<BoltCustomerStrategy> = (\n    paymentIntegrationService,\n) => {\n    return new BoltCustomerStrategy(\n        paymentIntegrationService,\n        new BoltScriptLoader(getScriptLoader()),\n    );\n};\n\nexport default toResolvableModule(createBoltCustomerStrategy, [{ id: 'bolt' }]);\n","import { isObject } from 'lodash';\n\nimport { LineItemMap } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport { ExtraItemsData } from './extra-items-data';\n\ntype StorageFallback = Pick<Storage, 'getItem' | 'setItem' | 'removeItem'>;\n\nconst ORDER_ITEMS_STORAGE_KEY = 'ORDER_ITEMS';\n\nfunction isExtraItemsData(itemsData: unknown): itemsData is ExtraItemsData {\n    if (!isObject(itemsData)) {\n        return false;\n    }\n\n    const hasNotExtraItems = Object.values(itemsData).some(\n        (item) => !isObject(item) || !('brand' in item) || !('category' in item),\n    );\n\n    return Boolean(!hasNotExtraItems);\n}\n\nexport default class AnalyticsExtraItemsManager {\n    constructor(private storage: StorageFallback) {}\n\n    saveExtraItemsData(id: string, lineItems: LineItemMap): ExtraItemsData {\n        const data = [...lineItems.physicalItems, ...lineItems.digitalItems].reduce<ExtraItemsData>(\n            (result, item) => {\n                result[item.productId] = {\n                    brand: item.brand ? item.brand : '',\n                    category: item.categoryNames ? item.categoryNames.join(', ') : '',\n                };\n\n                return result;\n            },\n            {},\n        );\n\n        try {\n            this.storage.setItem(this.getStorageKey(id), JSON.stringify(data));\n\n            return data;\n        } catch (err) {\n            return {};\n        }\n    }\n\n    readExtraItemsData(id: string): ExtraItemsData | null {\n        try {\n            const item = this.storage.getItem(this.getStorageKey(id));\n\n            if (!item) {\n                return null;\n            }\n\n            const data: unknown = JSON.parse(item);\n\n            return isExtraItemsData(data) ? data : null;\n        } catch (err) {\n            return null;\n        }\n    }\n\n    clearExtraItemData(id: string): void {\n        try {\n            this.storage.removeItem(this.getStorageKey(id));\n        } catch (err) {\n            // silently ignore the failure\n        }\n    }\n\n    private getStorageKey(id: string): string {\n        return id ? `${ORDER_ITEMS_STORAGE_KEY}_${id}` : '';\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * Throw this error if we are trying to make an order finalization request for a\n * payment method that does not require such procedure.\n */\nexport default class OrderFinalizationNotRequiredError extends StandardError {\n    constructor() {\n        super('The current order does not need to be finalized at this stage.');\n\n        this.name = 'OrderFinalizationNotRequiredError';\n        this.type = 'order_finalization_not_required';\n    }\n}\n","import InvalidArgumentError from './invalid-argument-error';\n\n/**\n * This error should be thrown when we are unable to submit a payment because\n * the caller has not provided all the required fields, i.e.: if an argument is\n * missing or it is not the expected data type.\n */\nexport default class PaymentArgumentInvalidError extends InvalidArgumentError {\n    constructor(invalidFields?: string[]) {\n        let message = 'Unable to submit payment for the order because the payload is invalid.';\n\n        if (invalidFields) {\n            message = `${message} Make sure the following fields are provided correctly: ${invalidFields.join(\n                ', ',\n            )}.`;\n        }\n\n        super(message);\n\n        this.name = 'PaymentArgumentInvalidError';\n    }\n}\n","import StandardError from './standard-error';\n\n/**\n * This error should be thrown when the payment flow is cancelled. It could be\n * due to a deliberate user interaction, i.e.: the user clicks on a cancel\n * button which dismisses the payment modal.\n */\nexport default class PaymentMethodCancelledError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Payment process was cancelled.');\n\n        this.name = 'PaymentMethodCancelledError';\n        this.type = 'payment_cancelled';\n    }\n}\n","import { WithAccountCreation } from './payment';\n\nexport default function isWithAccountCreation(\n    paymentData: unknown,\n): paymentData is WithAccountCreation {\n    return (\n        typeof paymentData === 'object' &&\n        paymentData !== null &&\n        'shouldCreateAccount' in paymentData\n    );\n}\n","import { PaymentErrorData, StandardError } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nexport default class BoltError extends StandardError {\n    body: { errors: PaymentErrorData[] };\n\n    constructor(public errorCode: string) {\n        super();\n\n        this.name = 'BoltPaymentsFieldError';\n        this.type = 'bolt_payments_field_error';\n        this.body = { errors: [BoltError.getError(errorCode)] };\n    }\n\n    private static getError(errorCode: string): PaymentErrorData {\n        switch (errorCode) {\n            case '1000':\n            case '2000':\n            case '3000':\n                return { code: 'invalid_number' };\n\n            case '1001':\n            case '2001':\n            case '3001':\n                return { code: 'invalid_expiry_date' };\n\n            case '1002':\n            case '2002':\n                return { code: 'invalid_cvc' };\n\n            case '1003':\n                return { code: 'invalid_zip' };\n\n            case '2003':\n                return { code: 'incorrect_zip' };\n\n            default:\n                return { code: 'general_error' };\n        }\n    }\n}\n","import {\n    AnalyticsExtraItemsManager,\n    isAnalyticsTrackerWindow,\n} from '@bigcommerce/checkout-sdk/analytics';\nimport {\n    InvalidArgumentError,\n    isWithAccountCreation,\n    MissingDataError,\n    MissingDataErrorType,\n    NonceInstrument,\n    NotInitializedError,\n    NotInitializedErrorType,\n    OrderFinalizationNotRequiredError,\n    OrderRequestBody,\n    Payment,\n    PaymentArgumentInvalidError,\n    PaymentInitializeOptions,\n    PaymentIntegrationService,\n    PaymentMethodCancelledError,\n    PaymentMethodFailedError,\n    PaymentMethodInvalidError,\n    PaymentRequestOptions,\n    PaymentStrategy,\n    WithAccountCreation,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport {\n    BoltCheckout,\n    BoltEmbedded,\n    BoltEmbeddedTokenize,\n    BoltEmbededField,\n    BoltPaymentMethod,\n    BoltTransaction,\n} from './bolt';\nimport BoltError from './bolt-error';\nimport { WithBoltPaymentInitializeOptions } from './bolt-payment-initialize-options';\nimport BoltScriptLoader from './bolt-script-loader';\nimport { isBoltPaymentData } from './is-bolt-payment-data';\n\nexport default class BoltPaymentStrategy implements PaymentStrategy {\n    private boltClient?: BoltCheckout;\n    private boltEmbedded?: BoltEmbedded;\n    private embeddedField?: BoltEmbededField;\n    private useBoltClient = false;\n    private useBoltEmbedded = false;\n\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private boltScriptLoader: BoltScriptLoader,\n        private analyticsExtraItemsManager: AnalyticsExtraItemsManager,\n    ) {}\n\n    async initialize(\n        options: PaymentInitializeOptions & WithBoltPaymentInitializeOptions,\n    ): Promise<void> {\n        const { bolt, methodId } = options;\n        const { containerId, onPaymentSelect, useBigCommerceCheckout } = bolt || {};\n\n        if (!methodId) {\n            throw new InvalidArgumentError(\n                'Unable to initialize payment because \"options.methodId\" argument is not provided.',\n            );\n        }\n\n        if (!useBigCommerceCheckout) {\n            // info: calling loadBoltClient method without providing any params is necessary for Bolt Full Checkout and Fraud Protection\n            this.boltClient = await this.boltScriptLoader.loadBoltClient();\n\n            return;\n        }\n\n        const paymentMethod: BoltPaymentMethod = this.paymentIntegrationService\n            .getState()\n            .getPaymentMethodOrThrow(options.methodId);\n\n        const { initializationData, config } = paymentMethod;\n        const { publishableKey, developerConfig, embeddedOneClickEnabled } =\n            initializationData || {};\n        const { testMode } = config;\n\n        if (!publishableKey) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        this.boltClient = await this.boltScriptLoader.loadBoltClient(\n            publishableKey,\n            testMode,\n            developerConfig,\n        );\n\n        this.useBoltClient = !embeddedOneClickEnabled;\n        this.useBoltEmbedded = !!embeddedOneClickEnabled;\n\n        if (this.useBoltEmbedded) {\n            if (!containerId) {\n                throw new InvalidArgumentError(\n                    'Unable to initialize payment because \"options.bolt.containerId\" argument is not provided.',\n                );\n            }\n\n            if (!onPaymentSelect) {\n                throw new InvalidArgumentError(\n                    'Unable to initialize payment because \"options.bolt.onPaymentSelect\" argument is not provided.',\n                );\n            }\n\n            this.boltEmbedded = await this.boltScriptLoader.loadBoltEmbedded(\n                publishableKey,\n                testMode,\n                developerConfig,\n            );\n\n            this.mountBoltEmbeddedField(containerId);\n            onPaymentSelect(await this.hasBoltAccount());\n        }\n    }\n\n    deinitialize(): Promise<void> {\n        this.embeddedField?.unmount();\n\n        this.boltClient = undefined;\n        this.boltEmbedded = undefined;\n\n        return Promise.resolve();\n    }\n\n    finalize(): Promise<void> {\n        return Promise.reject(new OrderFinalizationNotRequiredError());\n    }\n\n    async execute(payload: OrderRequestBody, options?: PaymentRequestOptions): Promise<void> {\n        this.setExtraItemsForAnalytics();\n\n        const { payment, ...order } = payload;\n        const { methodId, paymentData } = payment || {};\n        let paymentPayload;\n\n        if (!payload.payment) {\n            throw new PaymentArgumentInvalidError(['payment']);\n        }\n\n        if (!methodId) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        if (!paymentData || !isBoltPaymentData(paymentData)) {\n            throw new MissingDataError(MissingDataErrorType.MissingPayment);\n        }\n\n        await this.paymentIntegrationService.submitOrder(order, options);\n\n        if (this.useBoltClient) {\n            paymentPayload = await this.getBoltClientPaymentPayload(methodId, paymentData, options);\n        } else if (this.useBoltEmbedded) {\n            paymentPayload = await this.getBoltEmbeddedPaymentPayload(methodId, paymentData);\n        } else {\n            paymentPayload = await this.getBoltFullCheckoutPaymentPayload(methodId, paymentData);\n        }\n\n        await this.paymentIntegrationService.submitPayment(paymentPayload);\n    }\n\n    private async getBoltClientPaymentPayload(\n        methodId: string,\n        paymentData: NonceInstrument,\n        options?: PaymentRequestOptions,\n    ): Promise<Payment> {\n        await this.paymentIntegrationService.loadPaymentMethod(methodId, options);\n\n        const state = this.paymentIntegrationService.getState();\n        const paymentMethod = state.getPaymentMethodOrThrow(methodId);\n        const orderToken = paymentMethod.clientToken;\n        const { isStoreCreditApplied } = state.getCheckoutOrThrow();\n        const { shouldSaveInstrument } = paymentData;\n        const boltClient = this.getBoltClientOrThrow();\n\n        await this.paymentIntegrationService.applyStoreCredit(isStoreCreditApplied);\n\n        if (!orderToken) {\n            throw new MissingDataError(MissingDataErrorType.MissingPaymentMethod);\n        }\n\n        const boltTransaction: BoltTransaction = await new Promise((resolve, reject) => {\n            const onSuccess = (transaction: BoltTransaction, callback: () => void) => {\n                if (!transaction.reference) {\n                    reject(\n                        new PaymentMethodFailedError(\n                            'Unable to proceed because transaction reference is unavailable. Please try again later.',\n                        ),\n                    );\n                } else {\n                    resolve(transaction);\n                }\n\n                callback();\n            };\n\n            const onClose = () => {\n                reject(new PaymentMethodCancelledError());\n            };\n\n            const callbacks = {\n                success: onSuccess,\n                close: onClose,\n            };\n\n            boltClient.configure({ orderToken }, {}, callbacks).open();\n        });\n\n        return {\n            methodId,\n            paymentData: {\n                nonce: boltTransaction.reference,\n                shouldSaveInstrument,\n            },\n        };\n    }\n\n    private async getBoltEmbeddedPaymentPayload(\n        methodId: string,\n        paymentData: WithAccountCreation,\n    ): Promise<Payment> {\n        if (!isWithAccountCreation(paymentData)) {\n            throw new MissingDataError(MissingDataErrorType.MissingPayment);\n        }\n\n        const tokenizeResult = this.validateTokenizeResultOrThrow(\n            await this.embeddedField?.tokenize(),\n        );\n\n        return {\n            methodId,\n            paymentData: {\n                formattedPayload: {\n                    credit_card_token: {\n                        token: tokenizeResult.token,\n                        last_four_digits: tokenizeResult.last4,\n                        iin: tokenizeResult.bin,\n                        expiration_month: +tokenizeResult.expiration.split('-')[1],\n                        expiration_year: +tokenizeResult.expiration.split('-')[0],\n                    },\n                    provider_data: {\n                        create_account: !!paymentData.shouldCreateAccount,\n                        embedded_checkout: true,\n                    },\n                },\n            },\n        };\n    }\n\n    private async getBoltFullCheckoutPaymentPayload(\n        methodId: string,\n        paymentData: NonceInstrument,\n    ): Promise<Payment> {\n        await this.setBoltOrderId();\n\n        const boltClient = this.getBoltClientOrThrow();\n        const transactionReference = await boltClient.getTransactionReference();\n\n        if (!transactionReference) {\n            throw new PaymentMethodInvalidError();\n        }\n\n        return {\n            methodId,\n            paymentData: {\n                ...paymentData,\n                nonce: transactionReference,\n            },\n        };\n    }\n\n    private getBoltClientOrThrow(): BoltCheckout {\n        if (!this.boltClient) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        return this.boltClient;\n    }\n\n    private getBoltEmbeddedOrThrow() {\n        if (!this.boltEmbedded) {\n            throw new NotInitializedError(NotInitializedErrorType.PaymentNotInitialized);\n        }\n\n        return this.boltEmbedded;\n    }\n\n    private async hasBoltAccount(): Promise<boolean> {\n        const state = this.paymentIntegrationService.getState();\n        const customer = state.getCustomer();\n        const billingAddress = state.getBillingAddress();\n        const email = customer?.email || billingAddress?.email || '';\n        const boltClient = this.getBoltClientOrThrow();\n\n        try {\n            return await boltClient.hasBoltAccount(email);\n        } catch {\n            throw new PaymentMethodInvalidError();\n        }\n    }\n\n    private async setBoltOrderId() {\n        const order = this.paymentIntegrationService.getState().getOrderOrThrow();\n        const boltClient = this.getBoltClientOrThrow();\n\n        try {\n            await boltClient.setOrderId(order.orderId);\n        } catch {\n            throw new PaymentMethodInvalidError();\n        }\n    }\n\n    private mountBoltEmbeddedField(containerId: string) {\n        const boltEmbedded = this.getBoltEmbeddedOrThrow();\n        const styles = { backgroundColor: '#fff' };\n        const embeddedField = boltEmbedded.create('payment_field', {\n            styles,\n            renderSeparateFields: true,\n        });\n\n        embeddedField.mount(`#${containerId}`);\n\n        this.embeddedField = embeddedField;\n    }\n\n    private validateTokenizeResultOrThrow(\n        tokenizeResult?: BoltEmbeddedTokenize | Error,\n    ): BoltEmbeddedTokenize {\n        if (!tokenizeResult) {\n            throw new PaymentMethodInvalidError();\n        }\n\n        if (tokenizeResult instanceof Error) {\n            throw new BoltError(tokenizeResult.message);\n        }\n\n        const { token, last4, bin, expiration } = tokenizeResult;\n        const lastFourDigits = +last4;\n        const iin = +bin;\n        const expirationMonth = +`${expiration}`.split('-')[1];\n        const expirationYear = +`${expiration}`.split('-')[0];\n\n        if (\n            !token ||\n            Number.isNaN(lastFourDigits) ||\n            Number.isNaN(iin) ||\n            Number.isNaN(expirationMonth) ||\n            Number.isNaN(expirationYear)\n        ) {\n            throw new PaymentArgumentInvalidError();\n        }\n\n        return tokenizeResult;\n    }\n\n    private setExtraItemsForAnalytics() {\n        const state = this.paymentIntegrationService.getState();\n        const storeConfig = state.getStoreConfigOrThrow();\n        const cart = state.getCartOrThrow();\n\n        if (storeConfig.checkoutSettings.isAnalyticsEnabled && isAnalyticsTrackerWindow(window)) {\n            const { id, lineItems } = cart;\n\n            this.analyticsExtraItemsManager.saveExtraItemsData(id, lineItems);\n        }\n    }\n}\n","import { isObject } from 'lodash';\n\nimport { isWithAccountCreation } from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport { BoltPaymentData } from './bolt';\n\nexport function isBoltPaymentData(paymentData: unknown): paymentData is BoltPaymentData {\n    return Boolean(\n        isObject(paymentData) &&\n            ('shouldSaveInstrument' in paymentData ||\n                'nonce' in paymentData ||\n                isWithAccountCreation(paymentData)),\n    );\n}\n","import AnalyticsTrackerWindow from './analytics-tracker-window';\n\nexport function isAnalyticsTrackerWindow(window: Window): window is AnalyticsTrackerWindow {\n    return Boolean(window.hasOwnProperty('analytics'));\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\nimport localStorageFallback from 'local-storage-fallback';\n\nimport { AnalyticsExtraItemsManager } from '@bigcommerce/checkout-sdk/analytics';\nimport {\n    PaymentStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport BoltPaymentStrategy from './bolt-payment-strategy';\nimport BoltScriptLoader from './bolt-script-loader';\n\nconst createBoltPaymentStrategy: PaymentStrategyFactory<BoltPaymentStrategy> = (\n    paymentIntegrationService,\n) => {\n    return new BoltPaymentStrategy(\n        paymentIntegrationService,\n        new BoltScriptLoader(getScriptLoader()),\n        new AnalyticsExtraItemsManager(localStorageFallback),\n    );\n};\n\nexport default toResolvableModule(createBoltPaymentStrategy, [{ id: 'bolt' }]);\n","import StandardError from './standard-error';\n\n/**\n * Throw this error if we try to call a method that is only a stub and has not\n * been fully implemented.\n */\nexport default class NotImplementedError extends StandardError {\n    constructor(message?: string) {\n        super(message || 'Not implemented.');\n\n        this.name = 'NotImplementedError';\n        this.type = 'not_implemented';\n    }\n}\n","import { stringifyUrl } from 'query-string';\n\nimport {\n    CheckoutButtonInitializeOptions,\n    CheckoutButtonStrategy,\n    InvalidArgumentError,\n    NotImplementedError,\n    PaymentIntegrationService,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport {\n    BoltButtonStyleOptions,\n    BoltHostWindow,\n    BoltPaymentMethod,\n    StyleButtonShape,\n    StyleButtonSize,\n} from './bolt';\nimport { WithBoltButtonInitializeOptions } from './bolt-button-initialize-options';\nimport BoltScriptLoader from './bolt-script-loader';\n\nexport default class BoltButtonStrategy implements CheckoutButtonStrategy {\n    constructor(\n        private paymentIntegrationService: PaymentIntegrationService,\n        private boltScriptLoader: BoltScriptLoader,\n        public boltHostWindow: BoltHostWindow = window,\n    ) {}\n\n    async initialize(\n        options: CheckoutButtonInitializeOptions & WithBoltButtonInitializeOptions,\n    ): Promise<void> {\n        const { bolt, containerId, methodId } = options;\n        const { buyNowInitializeOptions, style } = bolt || {};\n\n        if (!methodId) {\n            throw new InvalidArgumentError(\n                'Unable to initialize payment because \"options.methodId\" argument is not provided.',\n            );\n        }\n\n        if (!containerId) {\n            throw new InvalidArgumentError(\n                `Unable to initialize payment because \"options.containerId\" argument is not provided.`,\n            );\n        }\n\n        if (!bolt) {\n            throw new InvalidArgumentError(\n                `Unable to initialize payment because \"options.bolt\" argument is not provided.`,\n            );\n        }\n\n        const isBuyNowFlow = Boolean(buyNowInitializeOptions);\n\n        if (!isBuyNowFlow) {\n            throw new NotImplementedError('Only buy now flow is implemented for Bolt button');\n        }\n\n        if (\n            !buyNowInitializeOptions?.storefrontApiToken ||\n            typeof buyNowInitializeOptions.storefrontApiToken !== 'string'\n        ) {\n            throw new InvalidArgumentError(\n                `Unable to initialize payment because \"options.storefrontApiToken\" argument is not provided.`,\n            );\n        }\n\n        const state = this.paymentIntegrationService.getState();\n        const paymentMethod: BoltPaymentMethod = state.getPaymentMethodOrThrow(methodId);\n        const { initializationData, config } = paymentMethod;\n        const { publishableKey, developerConfig } = initializationData || {};\n\n        await this.boltScriptLoader.loadBoltClient(\n            publishableKey,\n            config.testMode,\n            developerConfig,\n            'BigCommerce',\n            buyNowInitializeOptions.storefrontApiToken,\n        );\n\n        this.renderButton(containerId, paymentMethod, style);\n    }\n\n    deinitialize(): Promise<void> {\n        return Promise.resolve();\n    }\n\n    private renderButton(\n        containerId: string,\n        paymentMethod: BoltPaymentMethod,\n        style?: BoltButtonStyleOptions,\n    ): void {\n        if (typeof this.boltHostWindow.BoltConnect?.setupProductPageCheckout !== 'function') {\n            return;\n        }\n\n        this.addButtonContainer(containerId, paymentMethod, style);\n        this.boltHostWindow.BoltConnect.setupProductPageCheckout();\n    }\n\n    private addButtonContainer(\n        containerId: string,\n        paymentMethod: BoltPaymentMethod,\n        style?: BoltButtonStyleOptions,\n    ): void {\n        const container = document.getElementById(containerId);\n\n        if (!container) {\n            return;\n        }\n\n        const boltButtonContainer = document.createElement('div');\n        const boltButtonObject = document.createElement('object');\n\n        boltButtonContainer.setAttribute('id', 'product-page-checkout-wrapper');\n        boltButtonContainer.setAttribute('class', 'bolt-button-wrapper');\n        boltButtonContainer.setAttribute('style', 'display:none');\n        boltButtonContainer.setAttribute('data-tid', 'product-page-checkout-wrapper');\n\n        boltButtonObject.setAttribute('data', this.getBoltObjectData(paymentMethod, style));\n        boltButtonObject.setAttribute('class', 'bolt-product-checkout-button');\n\n        boltButtonContainer.append(boltButtonObject);\n        container.innerHTML = '';\n        container.append(boltButtonContainer);\n    }\n\n    private getBoltObjectData(\n        paymentMethod: BoltPaymentMethod,\n        style?: BoltButtonStyleOptions,\n    ): string {\n        const { initializationData, config } = paymentMethod;\n        const { publishableKey, developerConfig } = initializationData || {};\n\n        const domainUrl = this.boltScriptLoader.getDomainURL(!!config.testMode, developerConfig);\n        const buttonHeight = this.getButtonHeight(style?.size);\n        const buttonBorderRadius = this.getButtonBorderRadius(style?.shape, buttonHeight);\n\n        return stringifyUrl({\n            url: `https://${domainUrl}/v1/checkout_button`,\n            query: {\n                publishable_key: publishableKey,\n                variant: 'ppc',\n                height: buttonHeight,\n                border_radius: buttonBorderRadius,\n            },\n        });\n    }\n\n    private getButtonHeight(buttonSize?: StyleButtonSize): number | undefined {\n        if (!buttonSize) {\n            return;\n        }\n\n        switch (buttonSize) {\n            case StyleButtonSize.Small:\n                return 25;\n\n            case StyleButtonSize.Large:\n                return 45;\n\n            case StyleButtonSize.Medium:\n            default:\n                return 40;\n        }\n    }\n\n    private getButtonBorderRadius(\n        buttonShape?: StyleButtonShape,\n        buttonHeight?: number,\n    ): number | undefined {\n        if (!buttonShape) {\n            return;\n        }\n\n        switch (buttonShape) {\n            case StyleButtonShape.Pill:\n                return buttonHeight ? Math.round(buttonHeight / 2) : undefined;\n\n            case StyleButtonShape.Rect:\n            default:\n                return 4;\n        }\n    }\n}\n","import { getScriptLoader } from '@bigcommerce/script-loader';\n\nimport {\n    CheckoutButtonStrategyFactory,\n    toResolvableModule,\n} from '@bigcommerce/checkout-sdk/payment-integration-api';\n\nimport BoltButtonStrategy from './bolt-button-strategy';\nimport BoltScriptLoader from './bolt-script-loader';\n\nconst createBoltButtonStrategy: CheckoutButtonStrategyFactory<BoltButtonStrategy> = (\n    paymentIntegrationService,\n) => {\n    return new BoltButtonStrategy(\n        paymentIntegrationService,\n        new BoltScriptLoader(getScriptLoader()),\n    );\n};\n\nexport default toResolvableModule(createBoltButtonStrategy, [{ id: 'bolt' }]);\n"],"names":["MissingDataErrorType","NotInitializedErrorType","__webpack_require__","toResolvableModule","module","resolveIds","Object","assign","d","exports","definition","key","o","defineProperty","enumerable","get","obj","prop","prototype","hasOwnProperty","call","StandardError","Error","constructor","message","super","name","type","setPrototypeOf","this","__proto__","captureStackTrace","stack","InvalidArgumentError","MissingDataError","subtype","MissingBillingAddress","MissingCart","MissingConsignments","MissingCheckout","MissingCustomer","MissingCheckoutConfig","MissingOrderConfig","MissingOrder","MissingOrderId","MissingPayment","MissingPaymentToken","MissingPaymentMethod","MissingShippingAddress","getErrorMessage","PaymentMethodFailedError","NotInitializedError","CustomerNotInitialized","PaymentNotInitialized","ShippingNotInitialized","SpamProtectionNotInitialized","DEFAULT_RESPONSE","body","headers","status","RequestError","response","errors","PaymentMethodInvalidError","BoltDeveloperMode","StyleButtonSize","StyleButtonShape","BoltCustomerStrategy","paymentIntegrationService","boltScriptLoader","boltHostWindow","window","initialize","options","methodId","bolt","onInit","loadPaymentMethod","paymentMethod","getState","getPaymentMethodOrThrow","initializationData","publishableKey","developerConfig","loadBoltClient","config","testMode","email","getCustomerEmail","hasBoltAccount","deinitialize","Promise","resolve","signIn","credentials","signInCustomer","signOut","signOutCustomer","executePaymentMethodCheckout","continueWithCheckoutCallback","noop","checkoutPaymentMethodExecuted","openBoltCheckoutModalOrThrow","boltClient","getBoltClientOrThrow","getPaymentMethod","embeddedOneClickEnabled","callbacks","close","openCheckout","error","isCustomError","BoltCheckout","state","customer","getCustomer","billingAddress","getBillingAddress","PaymentMethodClientUnavailableError","BoltScriptLoader","scriptLoader","developerModeParams","cartId","storefrontApiToken","loadScript","getDomainURL","getScriptOptions","loadBoltEmbedded","async","attributes","id","Bolt","developerMode","StagingMode","DevelopmentMode","developerDomain","getScriptLoader","AnalyticsExtraItemsManager","storage","saveExtraItemsData","lineItems","data","physicalItems","digitalItems","reduce","result","item","productId","brand","category","categoryNames","join","setItem","getStorageKey","JSON","stringify","err","readExtraItemsData","getItem","parse","itemsData","isObject","hasNotExtraItems","values","some","Boolean","isExtraItemsData","clearExtraItemData","removeItem","OrderFinalizationNotRequiredError","PaymentArgumentInvalidError","invalidFields","PaymentMethodCancelledError","isWithAccountCreation","paymentData","BoltError","errorCode","getError","code","BoltPaymentStrategy","analyticsExtraItemsManager","useBoltClient","useBoltEmbedded","containerId","onPaymentSelect","useBigCommerceCheckout","boltEmbedded","mountBoltEmbeddedField","embeddedField","unmount","undefined","finalize","reject","execute","payload","setExtraItemsForAnalytics","payment","order","paymentPayload","isBoltPaymentData","submitOrder","getBoltClientPaymentPayload","getBoltEmbeddedPaymentPayload","getBoltFullCheckoutPaymentPayload","submitPayment","orderToken","clientToken","isStoreCreditApplied","getCheckoutOrThrow","shouldSaveInstrument","applyStoreCredit","boltTransaction","success","transaction","callback","reference","configure","open","nonce","tokenizeResult","validateTokenizeResultOrThrow","tokenize","formattedPayload","credit_card_token","token","last_four_digits","last4","iin","bin","expiration_month","expiration","split","expiration_year","provider_data","create_account","shouldCreateAccount","embedded_checkout","setBoltOrderId","transactionReference","getTransactionReference","getBoltEmbeddedOrThrow","getOrderOrThrow","setOrderId","orderId","create","styles","backgroundColor","renderSeparateFields","mount","lastFourDigits","expirationMonth","expirationYear","Number","isNaN","storeConfig","getStoreConfigOrThrow","cart","getCartOrThrow","checkoutSettings","isAnalyticsEnabled","isAnalyticsTrackerWindow","NotImplementedError","BoltButtonStrategy","buyNowInitializeOptions","style","renderButton","BoltConnect","setupProductPageCheckout","addButtonContainer","container","document","getElementById","boltButtonContainer","createElement","boltButtonObject","setAttribute","getBoltObjectData","append","innerHTML","domainUrl","buttonHeight","getButtonHeight","size","buttonBorderRadius","getButtonBorderRadius","shape","stringifyUrl","url","query","publishable_key","variant","height","border_radius","buttonSize","Small","Large","Medium","buttonShape","Pill","Math","round","Rect"],"sourceRoot":""}